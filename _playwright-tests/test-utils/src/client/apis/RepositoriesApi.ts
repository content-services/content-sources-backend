/* tslint:disable */
/* eslint-disable */
/**
 * ContentSourcesBackend
 * The API for the repositories of the content sources that you can use to create and manage repositories between third-party applications and the [Red Hat Hybrid Cloud Console](https://console.redhat.com). With these repositories, you can build and deploy images using Image Builder for Cloud, on-Premise, and Edge. You can handle tasks, search for required RPMs, fetch a GPGKey from the URL, and list the features within applications. 
 *
 * The version of the OpenAPI document: v1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiAddUploadsRequest,
  ApiCreateUploadRequest,
  ApiRepositoryCollectionResponse,
  ApiRepositoryExportRequest,
  ApiRepositoryExportResponse,
  ApiRepositoryImportResponse,
  ApiRepositoryIntrospectRequest,
  ApiRepositoryParameterResponse,
  ApiRepositoryRequest,
  ApiRepositoryResponse,
  ApiRepositoryUpdateRequest,
  ApiRepositoryValidationRequest,
  ApiRepositoryValidationResponse,
  ApiTaskInfoResponse,
  ApiUUIDListRequest,
  ApiUploadResponse,
  ErrorsErrorResponse,
} from '../models/index';
import {
    ApiAddUploadsRequestFromJSON,
    ApiAddUploadsRequestToJSON,
    ApiCreateUploadRequestFromJSON,
    ApiCreateUploadRequestToJSON,
    ApiRepositoryCollectionResponseFromJSON,
    ApiRepositoryCollectionResponseToJSON,
    ApiRepositoryExportRequestFromJSON,
    ApiRepositoryExportRequestToJSON,
    ApiRepositoryExportResponseFromJSON,
    ApiRepositoryExportResponseToJSON,
    ApiRepositoryImportResponseFromJSON,
    ApiRepositoryImportResponseToJSON,
    ApiRepositoryIntrospectRequestFromJSON,
    ApiRepositoryIntrospectRequestToJSON,
    ApiRepositoryParameterResponseFromJSON,
    ApiRepositoryParameterResponseToJSON,
    ApiRepositoryRequestFromJSON,
    ApiRepositoryRequestToJSON,
    ApiRepositoryResponseFromJSON,
    ApiRepositoryResponseToJSON,
    ApiRepositoryUpdateRequestFromJSON,
    ApiRepositoryUpdateRequestToJSON,
    ApiRepositoryValidationRequestFromJSON,
    ApiRepositoryValidationRequestToJSON,
    ApiRepositoryValidationResponseFromJSON,
    ApiRepositoryValidationResponseToJSON,
    ApiTaskInfoResponseFromJSON,
    ApiTaskInfoResponseToJSON,
    ApiUUIDListRequestFromJSON,
    ApiUUIDListRequestToJSON,
    ApiUploadResponseFromJSON,
    ApiUploadResponseToJSON,
    ErrorsErrorResponseFromJSON,
    ErrorsErrorResponseToJSON,
} from '../models/index';

export interface AddUploadRequest {
    uuid: string;
    apiAddUploadsRequest: ApiAddUploadsRequest;
}

export interface BulkCreateRepositoriesRequest {
    apiRepositoryRequest: Array<ApiRepositoryRequest>;
}

export interface BulkDeleteRepositoriesRequest {
    apiUUIDListRequest: ApiUUIDListRequest;
}

export interface BulkExportRepositoriesRequest {
    apiRepositoryExportRequest: ApiRepositoryExportRequest;
}

export interface BulkImportRepositoriesRequest {
    apiRepositoryRequest: Array<ApiRepositoryRequest>;
}

export interface CreateRepositoryRequest {
    apiRepositoryRequest: Omit<ApiRepositoryRequest, 'origin'>;
}

export interface CreateSnapshotRequest {
    uuid: string;
}

export interface CreateUploadRequest {
    apiCreateUploadRequest: ApiCreateUploadRequest;
}

export interface DeleteRepositoryRequest {
    uuid: string;
}

export interface FullUpdateRepositoryRequest {
    uuid: string;
    apiRepositoryRequest: Omit<ApiRepositoryRequest, 'origin'>;
}

export interface GetGpgKeyFileRequest {
    uuid: string;
}

export interface GetLatestRepoConfigurationFileRequest {
    uuid: string;
}

export interface GetRepoConfigurationFileRequest {
    snapshotUuid: string;
}

export interface GetRepositoryRequest {
    uuid: string;
}

export interface IntrospectRequest {
    uuid: string;
    apiRepositoryIntrospectRequest?: ApiRepositoryIntrospectRequest;
}

export interface ListRepositoriesRequest {
    offset?: number;
    limit?: number;
    version?: string;
    arch?: string;
    availableForVersion?: string;
    availableForArch?: string;
    search?: string;
    name?: string;
    url?: string;
    uuid?: string;
    sortBy?: string;
    status?: string;
    origin?: string;
    contentType?: string;
}

export interface PartialUpdateRepositoryRequest {
    uuid: string;
    apiRepositoryUpdateRequest: ApiRepositoryUpdateRequest;
}

export interface UploadChunkRequest {
    uploadUuid: string;
    contentRange: string;
    file: Blob;
    sha256: string;
}

export interface ValidateRepositoryParametersRequest {
    apiRepositoryValidationRequest: Array<ApiRepositoryValidationRequest>;
}

/**
 * 
 */
export class RepositoriesApi extends runtime.BaseAPI {

    /**
     * Add uploads to a repository.
     * Add uploads to a repository
     */
    async addUploadRaw(requestParameters: AddUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiTaskInfoResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling addUpload().'
            );
        }

        if (requestParameters['apiAddUploadsRequest'] == null) {
            throw new runtime.RequiredError(
                'apiAddUploadsRequest',
                'Required parameter "apiAddUploadsRequest" was null or undefined when calling addUpload().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/{uuid}/add_uploads/`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiAddUploadsRequestToJSON(requestParameters['apiAddUploadsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiTaskInfoResponseFromJSON(jsonValue));
    }

    /**
     * Add uploads to a repository.
     * Add uploads to a repository
     */
    async addUpload(requestParameters: AddUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiTaskInfoResponse> {
        const response = await this.addUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This enables creating multiple repositories in a single API. If a user encounters any error, none of the repositories will be created. The applicable error message will be returned.
     * Bulk create repositories
     */
    async bulkCreateRepositoriesRaw(requestParameters: BulkCreateRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiRepositoryResponse>>> {
        if (requestParameters['apiRepositoryRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryRequest',
                'Required parameter "apiRepositoryRequest" was null or undefined when calling bulkCreateRepositories().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/bulk_create/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['apiRepositoryRequest']!.map(ApiRepositoryRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiRepositoryResponseFromJSON));
    }

    /**
     * This enables creating multiple repositories in a single API. If a user encounters any error, none of the repositories will be created. The applicable error message will be returned.
     * Bulk create repositories
     */
    async bulkCreateRepositories(requestParameters: BulkCreateRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiRepositoryResponse>> {
        const response = await this.bulkCreateRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This enables deleting multiple repositories.
     * Bulk delete repositories
     */
    async bulkDeleteRepositoriesRaw(requestParameters: BulkDeleteRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['apiUUIDListRequest'] == null) {
            throw new runtime.RequiredError(
                'apiUUIDListRequest',
                'Required parameter "apiUUIDListRequest" was null or undefined when calling bulkDeleteRepositories().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/bulk_delete/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiUUIDListRequestToJSON(requestParameters['apiUUIDListRequest']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This enables deleting multiple repositories.
     * Bulk delete repositories
     */
    async bulkDeleteRepositories(requestParameters: BulkDeleteRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.bulkDeleteRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Export multiple repositories.
     * Bulk export repositories
     */
    async bulkExportRepositoriesRaw(requestParameters: BulkExportRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiRepositoryExportResponse>>> {
        if (requestParameters['apiRepositoryExportRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryExportRequest',
                'Required parameter "apiRepositoryExportRequest" was null or undefined when calling bulkExportRepositories().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/bulk_export/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiRepositoryExportRequestToJSON(requestParameters['apiRepositoryExportRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiRepositoryExportResponseFromJSON));
    }

    /**
     * Export multiple repositories.
     * Bulk export repositories
     */
    async bulkExportRepositories(requestParameters: BulkExportRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiRepositoryExportResponse>> {
        const response = await this.bulkExportRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Import multiple repositories.
     * Bulk import repositories
     */
    async bulkImportRepositoriesRaw(requestParameters: BulkImportRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiRepositoryImportResponse>>> {
        if (requestParameters['apiRepositoryRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryRequest',
                'Required parameter "apiRepositoryRequest" was null or undefined when calling bulkImportRepositories().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/bulk_import/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['apiRepositoryRequest']!.map(ApiRepositoryRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiRepositoryImportResponseFromJSON));
    }

    /**
     * Import multiple repositories.
     * Bulk import repositories
     */
    async bulkImportRepositories(requestParameters: BulkImportRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiRepositoryImportResponse>> {
        const response = await this.bulkImportRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation enables creating custom repositories based on user preferences.
     * Create Repository
     */
    async createRepositoryRaw(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryResponse>> {
        if (requestParameters['apiRepositoryRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryRequest',
                'Required parameter "apiRepositoryRequest" was null or undefined when calling createRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiRepositoryRequestToJSON(requestParameters['apiRepositoryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryResponseFromJSON(jsonValue));
    }

    /**
     * This operation enables creating custom repositories based on user preferences.
     * Create Repository
     */
    async createRepository(requestParameters: CreateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryResponse> {
        const response = await this.createRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Snapshot a repository if not already snapshotting
     * snapshot a repository
     */
    async createSnapshotRaw(requestParameters: CreateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiTaskInfoResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling createSnapshot().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repositories/{uuid}/snapshot/`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiTaskInfoResponseFromJSON(jsonValue));
    }

    /**
     * Snapshot a repository if not already snapshotting
     * snapshot a repository
     */
    async createSnapshot(requestParameters: CreateSnapshotRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiTaskInfoResponse> {
        const response = await this.createSnapshotRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an upload.
     * Create an upload
     */
    async createUploadRaw(requestParameters: CreateUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiUploadResponse>> {
        if (requestParameters['apiCreateUploadRequest'] == null) {
            throw new runtime.RequiredError(
                'apiCreateUploadRequest',
                'Required parameter "apiCreateUploadRequest" was null or undefined when calling createUpload().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/uploads/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiCreateUploadRequestToJSON(requestParameters['apiCreateUploadRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUploadResponseFromJSON(jsonValue));
    }

    /**
     * Create an upload.
     * Create an upload
     */
    async createUpload(requestParameters: CreateUploadRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiUploadResponse> {
        const response = await this.createUploadRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This enables deleting a specific repository.
     * Delete a repository
     */
    async deleteRepositoryRaw(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling deleteRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repositories/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This enables deleting a specific repository.
     * Delete a repository
     */
    async deleteRepository(requestParameters: DeleteRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Update a repository.
     * Update Repository
     */
    async fullUpdateRepositoryRaw(requestParameters: FullUpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling fullUpdateRepository().'
            );
        }

        if (requestParameters['apiRepositoryRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryRequest',
                'Required parameter "apiRepositoryRequest" was null or undefined when calling fullUpdateRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ApiRepositoryRequestToJSON(requestParameters['apiRepositoryRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryResponseFromJSON(jsonValue));
    }

    /**
     * Update a repository.
     * Update Repository
     */
    async fullUpdateRepository(requestParameters: FullUpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryResponse> {
        const response = await this.fullUpdateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the GPG key file for a repository.
     * Get the GPG key file for a repository
     */
    async getGpgKeyFileRaw(requestParameters: GetGpgKeyFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getGpgKeyFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repository_gpg_key/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get the GPG key file for a repository.
     * Get the GPG key file for a repository
     */
    async getGpgKeyFile(requestParameters: GetGpgKeyFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getGpgKeyFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get latest configuration file for a repository
     */
    async getLatestRepoConfigurationFileRaw(requestParameters: GetLatestRepoConfigurationFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getLatestRepoConfigurationFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repositories/{uuid}/config.repo`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get latest configuration file for a repository
     */
    async getLatestRepoConfigurationFile(requestParameters: GetLatestRepoConfigurationFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getLatestRepoConfigurationFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get configuration file of a repository
     */
    async getRepoConfigurationFileRaw(requestParameters: GetRepoConfigurationFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['snapshotUuid'] == null) {
            throw new runtime.RequiredError(
                'snapshotUuid',
                'Required parameter "snapshotUuid" was null or undefined when calling getRepoConfigurationFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/snapshots/{snapshot_uuid}/config.repo`;
        urlPath = urlPath.replace(`{${"snapshot_uuid"}}`, encodeURIComponent(String(requestParameters['snapshotUuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get configuration file of a repository
     */
    async getRepoConfigurationFile(requestParameters: GetRepoConfigurationFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.getRepoConfigurationFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get repository information.
     * Get Repository
     */
    async getRepositoryRaw(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling getRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repositories/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryResponseFromJSON(jsonValue));
    }

    /**
     * Get repository information.
     * Get Repository
     */
    async getRepository(requestParameters: GetRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryResponse> {
        const response = await this.getRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check for repository updates.
     * introspect a repository
     */
    async introspectRaw(requestParameters: IntrospectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiTaskInfoResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling introspect().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/{uuid}/introspect/`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiRepositoryIntrospectRequestToJSON(requestParameters['apiRepositoryIntrospectRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiTaskInfoResponseFromJSON(jsonValue));
    }

    /**
     * Check for repository updates.
     * introspect a repository
     */
    async introspect(requestParameters: IntrospectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiTaskInfoResponse> {
        const response = await this.introspectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This operation enables users to retrieve a list of repositories.
     * List Repositories
     */
    async listRepositoriesRaw(requestParameters: ListRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryCollectionResponse>> {
        const queryParameters: any = {};

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['arch'] != null) {
            queryParameters['arch'] = requestParameters['arch'];
        }

        if (requestParameters['availableForVersion'] != null) {
            queryParameters['available_for_version'] = requestParameters['availableForVersion'];
        }

        if (requestParameters['availableForArch'] != null) {
            queryParameters['available_for_arch'] = requestParameters['availableForArch'];
        }

        if (requestParameters['search'] != null) {
            queryParameters['search'] = requestParameters['search'];
        }

        if (requestParameters['name'] != null) {
            queryParameters['name'] = requestParameters['name'];
        }

        if (requestParameters['url'] != null) {
            queryParameters['url'] = requestParameters['url'];
        }

        if (requestParameters['uuid'] != null) {
            queryParameters['uuid'] = requestParameters['uuid'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['origin'] != null) {
            queryParameters['origin'] = requestParameters['origin'];
        }

        if (requestParameters['contentType'] != null) {
            queryParameters['content_type'] = requestParameters['contentType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repositories/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryCollectionResponseFromJSON(jsonValue));
    }

    /**
     * This operation enables users to retrieve a list of repositories.
     * List Repositories
     */
    async listRepositories(requestParameters: ListRepositoriesRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryCollectionResponse> {
        const response = await this.listRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List repository parameters.
     * List Repository Parameters
     */
    async listRepositoryParametersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryParameterResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/repository_parameters/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryParameterResponseFromJSON(jsonValue));
    }

    /**
     * List repository parameters.
     * List Repository Parameters
     */
    async listRepositoryParameters(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryParameterResponse> {
        const response = await this.listRepositoryParametersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Partially update a repository.
     * Partial Update Repository
     */
    async partialUpdateRepositoryRaw(requestParameters: PartialUpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiRepositoryResponse>> {
        if (requestParameters['uuid'] == null) {
            throw new runtime.RequiredError(
                'uuid',
                'Required parameter "uuid" was null or undefined when calling partialUpdateRepository().'
            );
        }

        if (requestParameters['apiRepositoryUpdateRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryUpdateRequest',
                'Required parameter "apiRepositoryUpdateRequest" was null or undefined when calling partialUpdateRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repositories/{uuid}`;
        urlPath = urlPath.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters['uuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ApiRepositoryUpdateRequestToJSON(requestParameters['apiRepositoryUpdateRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiRepositoryResponseFromJSON(jsonValue));
    }

    /**
     * Partially update a repository.
     * Partial Update Repository
     */
    async partialUpdateRepository(requestParameters: PartialUpdateRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiRepositoryResponse> {
        const response = await this.partialUpdateRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a file chunk.
     * Upload a file chunk
     */
    async uploadChunkRaw(requestParameters: UploadChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApiUploadResponse>> {
        if (requestParameters['uploadUuid'] == null) {
            throw new runtime.RequiredError(
                'uploadUuid',
                'Required parameter "uploadUuid" was null or undefined when calling uploadChunk().'
            );
        }

        if (requestParameters['contentRange'] == null) {
            throw new runtime.RequiredError(
                'contentRange',
                'Required parameter "contentRange" was null or undefined when calling uploadChunk().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadChunk().'
            );
        }

        if (requestParameters['sha256'] == null) {
            throw new runtime.RequiredError(
                'sha256',
                'Required parameter "sha256" was null or undefined when calling uploadChunk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['contentRange'] != null) {
            headerParameters['Content-Range'] = String(requestParameters['contentRange']);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['sha256'] != null) {
            formParams.append('sha256', requestParameters['sha256'] as any);
        }


        let urlPath = `/repositories/uploads/{upload_uuid}/upload_chunk/`;
        urlPath = urlPath.replace(`{${"upload_uuid"}}`, encodeURIComponent(String(requestParameters['uploadUuid'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApiUploadResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file chunk.
     * Upload a file chunk
     */
    async uploadChunk(requestParameters: UploadChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApiUploadResponse> {
        const response = await this.uploadChunkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This validates the parameters before creating a repository. It provides a way to ensure the accuracy and validity of the provided parameters, including a check for the presence of remote yum metadata. Users can perform necessary checks before proceeding with the creation of a repository.
     * Validate parameters prior to creating a repository
     */
    async validateRepositoryParametersRaw(requestParameters: ValidateRepositoryParametersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ApiRepositoryValidationResponse>>> {
        if (requestParameters['apiRepositoryValidationRequest'] == null) {
            throw new runtime.RequiredError(
                'apiRepositoryValidationRequest',
                'Required parameter "apiRepositoryValidationRequest" was null or undefined when calling validateRepositoryParameters().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/repository_parameters/validate/`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['apiRepositoryValidationRequest']!.map(ApiRepositoryValidationRequestToJSON),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ApiRepositoryValidationResponseFromJSON));
    }

    /**
     * This validates the parameters before creating a repository. It provides a way to ensure the accuracy and validity of the provided parameters, including a check for the presence of remote yum metadata. Users can perform necessary checks before proceeding with the creation of a repository.
     * Validate parameters prior to creating a repository
     */
    async validateRepositoryParameters(requestParameters: ValidateRepositoryParametersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ApiRepositoryValidationResponse>> {
        const response = await this.validateRepositoryParametersRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
